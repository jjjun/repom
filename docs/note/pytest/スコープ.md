# スコープの問題

sqlalchemyでテーブルと紐づいたモデルをテスト内で定義する際に問題が出ました。それぞれファイルが二つあり、次の様に書いてあります。

```
# docs/pytest/sample_スコープ/sample1.py

import pytest
from mine_db.base_model import BaseModel

class Sample1Model(BaseModel):
    __tablename__ = 'sample_model'
```

```
# docs/pytest/sample_スコープ/sample2.py
import pytest
from mine_db.base_model import BaseModel

class Sample1Model(BaseModel):
    __tablename__ = 'sample_model'
```

`BaseModel` はモデルの基底クラス、つまりは全てのモデルで共通して使う様な処理を書いています。

これを、単純に一つだけテストを実行する様にするとエラーは出ません。私の環境で言うと次です。

```
# エラー出ない
poetry run pytest 'docs/pytest/sample_スコープ/sample1.py'
# エラー出ない
poetry run pytest 'docs/pytest/sample_スコープ/sample2.py'
```

しかし、二つのテストを実行するとエラーが出ます。

```
# エラーが出る
poetry run pytest 'docs/pytest/sample_スコープ/sample1.py' 'docs/pytest/sample_スコープ/sample2.py'
 # sqlalchemy.exc.InvalidRequestError: Table 'sample_model' is already defined for this MetaData instance.  Specify 'extend_existing=True' to redefine options and columns on an existing Table object.
```

このエラーは SQLAlchemy が同じテーブル名を持つ複数のモデルクラスを同じメタデータインスタンスに登録しようとするために発生します。具体的には、sample_model というテーブル名が既に定義されているため、再定義しようとするとエラーが発生します。

これを解決するには次の事をするとよい。

- `Sample1Model` を別ファイルで定義して、それをそれぞれのテストファイルでインポートする様な形にすると、エラーは出ない。
- モデル定義時に `extend_existing=True` を使用すると、テーブルを再定義する際に既存のテーブル定義を拡張するので、エラーは出ない。

`extend_existing=True` は次のような感じ使う。

```
class Sample1Model(Base):
    __tablename__ = 'sample_model'
    __table_args__ = {'extend_existing': True}
```

## 分からない事

- テストファイルは分かれてるけど、テストファイルごとにクラスが共有されているの？
- 共通のファイルにモデルクラスを定義する事で、エラーが出なくなるのはなぜ？


## テストファイル事に変数やクラスが共有されているのかをチェックした

先ず変数。次の様にして、`sample3py` -> `sample4.py` と実行した。

```
# sample3.py
greet = 'hello!!'
print(greet)
```

```
# sample4.py
print(greet)
```

結果は `sample3.py` は正しく動くけど、`sample4.py` は正しく動かなかった。同様に、`sample3.py` で クラスを定義して使ってみるも、同じ結果になった。つまりは、ファイルごとにスコープは異なっているという事が分かる。

```
class Greeter:
    @staticmethod
    def greet():
        return 'hello!!'

print(Greeter.greet())
```

## 結果

SQLAlchemy の MetaData オブジェクトは、データベーススキーマ情報を管理するために使用され、通常はアプリケーション全体で共有されるように設計されています。

MetaData オブジェクトは、データベースのテーブル定義やスキーマ情報を管理します。通常、declarative_base を使用して生成される Base クラスに含まれています。

```
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
```

この Base クラスは、アプリケーション全体で共有されることを意図して設計されています。したがって、異なるテストファイルで同じ Base クラスを使用すると、同じ MetaData オブジェクトが共有されます。


## Python のモジュールのインポートメカニズム

Python のモジュールは、一度インポートされると、同じプロセス内で再度インポートされることはありません。つまり、同じモジュールが複数回インポートされても、最初にインポートされたインスタンスが再利用されます。


## SQLAlchemy の base オブジェクトの ような感じの書き方をして、実際に値が共有されている事を確認した。

次のようなモジュールを用意しました。

```
# sample5_6_module.py
class SharedData:
    _data = []

    @classmethod
    def add_data(cls, value):
        cls._data.append(value)

    @classmethod
    def get_data(cls):
        return cls._data
```

実際に次のようにテストを実行すると、両方のテストファイルで値が共有していたことを確認した。

```
poetry run pytest 'docs/pytest/sample_スコープ/sample5.py' 'docs/pytest/sample_スコープ/sample6.py'
```
